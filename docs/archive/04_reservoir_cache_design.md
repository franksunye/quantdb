# "蓄水池"缓存机制设计

## 1. 概述

"蓄水池"缓存机制是QuantDB的核心组件，它作为AKShare等外部数据源之上的智能中间层，优化数据获取和缓存流程，提高系统性能和稳定性。该机制通过智能数据注入策略、数据新鲜度跟踪和降级回退机制，确保系统在高负载和外部数据源不稳定的情况下仍能提供高质量的服务。

### 1.1 设计目标

- **提高性能**: 减少对外部数据源的直接依赖，提高数据访问速度
- **优化资源**: 只缓存必要的数据，减少存储和处理开销
- **增强稳定性**: 在外部数据源不可用时提供服务连续性
- **支持多用户**: 支持多Agent/用户共享数据上下文
- **智能适应**: 根据访问模式自动调整缓存策略

### 1.2 核心概念

- **数据注入策略**: 决定哪些数据应该进入缓存
- **数据新鲜度**: 跟踪缓存数据的时效性
- **缓存命中率**: 衡量缓存效率的关键指标
- **降级回退**: 在数据源不可用时的服务保障机制
- **智能预加载**: 基于访问模式预测需要的数据

## 2. 系统架构

### 2.1 组件结构

```
┌─────────────────────────────────────────────────────┐
│                  应用层 (API/MCP)                    │
└───────────────────────┬─────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────┐
│                    数据服务层                        │
└───────────────────────┬─────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────┐
│                 "蓄水池"缓存层                       │
│                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │ 缓存引擎    │  │ 数据注入    │  │ 新鲜度跟踪  │  │
│  │            │  │ 策略器      │  │            │  │
│  └─────────────┘  └─────────────┘  └─────────────┘  │
│                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │ 数据复用    │  │ 降级回退    │  │ 智能预加载  │  │
│  │ 索引器      │  │ 管理器      │  │            │  │
│  └─────────────┘  └─────────────┘  └─────────────┘  │
│                                                     │
└───────────────────────┬─────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────┐
│                  数据适配器层                        │
│                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │
│  │ AKShare     │  │ 其他数据源  │  │ 本地数据    │  │
│  │ 适配器      │  │ 适配器      │  │ 适配器      │  │
│  └─────────────┘  └─────────────┘  └─────────────┘  │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 2.2 核心组件

#### 2.2.1 缓存引擎 (`cache_engine.py`)

缓存引擎是"蓄水池"机制的核心，负责管理缓存数据的存储和检索。

**主要功能**:
- 缓存键生成
- 缓存数据存储和检索
- 缓存过期管理
- 缓存命中率统计

**接口**:
```python
def get(cache_key: str) -> Optional[Any]
def set(cache_key: str, data: Any, ttl: int = None) -> bool
def invalidate(cache_key: str) -> bool
def get_stats() -> Dict[str, Any]
```

#### 2.2.2 数据注入策略器 (`data_injector.py`)

数据注入策略器决定哪些数据应该进入缓存，基于访问频率、数据大小和更新频率等因素。

**主要功能**:
- 访问频率分析
- 数据大小评估
- 更新频率需求分析
- 用户/Agent行为模式分析

**接口**:
```python
def should_cache(data_type: str, data_size: int, access_pattern: Dict[str, Any]) -> bool
def get_ttl(data_type: str, access_pattern: Dict[str, Any]) -> int
def update_access_pattern(cache_key: str, access_time: datetime) -> None
```

#### 2.2.3 数据新鲜度跟踪器 (`freshness_tracker.py`)

数据新鲜度跟踪器管理缓存数据的时效性，确保用户获取的数据符合新鲜度要求。

**主要功能**:
- 数据时间戳管理
- 数据过期策略
- 增量更新触发
- 新鲜度状态API

**接口**:
```python
def is_fresh(cache_key: str, freshness_requirement: str) -> bool
def mark_updated(cache_key: str, ttl: Optional[int] = None) -> None
def mark_stale(cache_key: str) -> bool
def mark_expired(cache_key: str) -> bool
def get_freshness_status(cache_key: str) -> Dict[str, Any]
def schedule_update(cache_key: str, priority: int = 0) -> None
def cancel_update(cache_key: str) -> bool
```

#### 2.2.4 AKShare适配器 (`akshare_adapter.py`)

AKShare适配器统一封装AKShare API的调用，处理错误和重试，与缓存引擎集成。

**主要功能**:
- AKShare API封装
- 错误处理和重试
- 数据格式标准化
- 与缓存引擎集成

**接口**:
```python
def get_stock_data(symbol: str, start_date: str = None, end_date: str = None) -> pd.DataFrame
def get_index_data(symbol: str, start_date: str = None, end_date: str = None) -> pd.DataFrame
def get_stock_list() -> pd.DataFrame
def get_index_list() -> pd.DataFrame
def get_index_constituents(index_symbol: str) -> pd.DataFrame
```

## 3. 数据流程

### 3.1 数据请求流程

1. 用户/Agent发起请求（通过API或MCP）
2. 系统生成缓存键
3. 检查请求的数据是否已缓存
   - 如果已缓存且新鲜，直接返回缓存数据
   - 如果已缓存但不新鲜，触发异步更新并返回缓存数据（标记为"可能不是最新"）
   - 如果未缓存，继续下一步
4. 系统通过AKShare适配器从外部源获取数据
5. 数据经过清洗和标准化
6. 数据注入策略器决定是否将数据存入缓存
7. 如果决定缓存，数据存入缓存并添加新鲜度标记
8. 返回数据给用户/Agent

### 3.2 缓存更新流程

1. 系统定期检查缓存数据的新鲜度
2. 对于即将过期的数据，触发预更新
3. 对于高频访问的数据，提高更新优先级
4. 系统在低负载时段执行批量更新
5. 更新后的数据替换缓存中的旧数据
6. 更新数据新鲜度标记

### 3.3 降级回退流程

1. 系统检测到外部数据源不可用
2. 激活降级回退机制
3. 对于缓存中的数据，延长过期时间
4. 对于未缓存的数据，尝试使用替代数据源
5. 如果无法获取数据，返回最近的缓存数据（标记为"可能过期"）
6. 当外部数据源恢复后，触发批量更新

## 4. 实现计划

### 4.1 MVP阶段实现

在MVP阶段，我们将实现以下核心功能：

1. **基础缓存引擎**
   - 实现缓存键生成策略
   - 实现基本的缓存存储和检索
   - 实现简单的过期策略

2. **AKShare适配器**
   - 封装常用的AKShare API调用
   - 实现错误处理和重试机制
   - 与缓存引擎集成

3. **数据新鲜度跟踪**
   - 为缓存数据添加时间戳
   - 实现基本的新鲜度检查
   - 提供新鲜度状态API

### 4.2 后续增强

在MVP之后，我们将增强"蓄水池"机制：

1. **增强数据注入策略**
   - 实现基于访问频率的注入策略
   - 实现基于数据大小的注入策略
   - 实现基于更新频率的注入策略

2. **开发缓存性能监控**
   - 实现缓存命中率统计
   - 实现缓存使用情况监控
   - 提供缓存性能API

3. **实现智能预加载机制**
   - 基于用户/Agent行为模式预测需要的数据
   - 实现后台预加载任务
   - 优化缓存命中率

## 5. 性能指标

"蓄水池"机制的性能目标：

- **响应时间**: 50ms (≥95%命中率)
- **缓存命中率**: ≥95%
- **数据延迟**: <10分钟
- **服务可用性**: 99.9%
- **存储效率**: 只缓存实际需要的数据，存储使用率>80%

## 6. 总结

"蓄水池"缓存机制是QuantDB的核心组件，通过智能数据管理策略，显著提高系统性能、稳定性和可用性。该机制作为AKShare等外部数据源之上的智能中间层，优化数据获取和管理流程，为用户/Agent提供高效、可靠的金融数据服务。

在MVP阶段，我们将实现基础的缓存引擎、AKShare适配器和数据新鲜度跟踪，为后续的增强功能奠定基础。这些组件将与现有的API和MCP协议无缝集成，提供统一的数据访问体验。
